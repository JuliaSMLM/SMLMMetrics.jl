var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SMLMMetrics","category":"page"},{"location":"#SMLMMetrics","page":"Home","title":"SMLMMetrics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SMLMMetrics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SMLMMetrics]","category":"page"},{"location":"#SMLMMetrics.efficiency","page":"Home","title":"SMLMMetrics.efficiency","text":"efficiency(a::Array{<:Real}, b::Array{<:Real}, cutoff::Vector{<:Real}, α::Union{Nothing, Vector{<:Real}}=nothing)\n\nCalculate the efficiency metric between two sets a and b  using a maximum connection distance of cutoff for the Jaccard Index,  and a dimensional weighting α for the RMSE. The efficiency is defined as:\n\nE = 1 - sqrt(1 - JI)^2 + α^2 * RMSE^2\n\na and b are d x n, and d x m arrays, where d is the number of dimensions.   cutoff contains the maximum matching distance for each dimension for the Jaccard Index.   α contains the dimensional weighting for the RMSE.\n\nLateral and axial efficiencies are calculated separately and then averaged to obtain the overall efficiency.  The first two dimensions are considered lateral and the third dimension is considered axial.  The default alpha values are α = 1 × 10^{-2} nm^{-1} for lateral and α = 0.5 × 10^{-2} nm^{-1} for axial. The units of α should be the inverse of the units of a and b.\n\nDetection accuracy is expressed in units of 0 to 1.  The efficiency ranges up to 100% for a perfect fitting algorithm.\n\n\n\n\n\n","category":"function"},{"location":"#SMLMMetrics.efficiency-Tuple{SMLMData.SMLD2D, SMLMData.SMLD2D, Vector{<:Real}}","page":"Home","title":"SMLMMetrics.efficiency","text":"efficiency(a::SMLMData.SMLD2D, b::SMLMData.SMLD2D, cutoff::Vector{<:Real}; α::Vector{<:Real} = (default is [1e-2, 1e-2, 5e-2]))\n\nCalculate the efficiency between two sets of 2D SMLM data a and b using a maximum connection distance of cutoff. α is an optional argument that provides weights for each dimension. (default is [1e-2 1e-2 5e-2])\n\nThe function first converts the data from the SMLD2D format into coordinate arrays, and then calculates the efficiency  using the provided cutoff and α parameters.\n\nReturns the calculated efficiency value.\n\nExamples\n\nefficiency(data1, data2, [1.0, 1.0])\nefficiency(data1, data2, [1.0, 1.0], [0.5, 0.5])\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.efficiency-Tuple{SMLMData.SMLD3D, SMLMData.SMLD3D, Vector{<:Real}}","page":"Home","title":"SMLMMetrics.efficiency","text":"efficiency(a::SMLMData.SMLD3D, b::SMLMData.SMLD3D, cutoff::Vector{<:Real}; α::Vector{<:Real} = ones(3))\n\nCalculate the efficiency between two sets of 3D SMLM data a and b using a maximum connection distance of cutoff. α is an optional argument that provides weights for each dimension.\n\nThe function first converts the data from the SMLD3D format into coordinate arrays, and then calculates the efficiency  using the provided cutoff and α parameters.\n\nReturns the calculated efficiency value.\n\nExamples\n\nefficiency(data1, data2, [1.0, 1.0, 1.0])\nefficiency(data1, data2, [1.0, 1.0, 1.0], [0.5, 0.5, 0.5])\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.jaccard-Tuple{Any, Any, Any}","page":"Home","title":"SMLMMetrics.jaccard","text":"jaccard(a, b, cutoff)\n\nCalculate the Jaccard Index between the two sets a and b  using a maximum connection distance of cutoff.    \n\nThe Jaccard index is defined as:\n\nJ(A,B) =  |A ∩ B| / |A ∪ B|\n\nThe intersecting elements of A and B found by building and minimizing   a cost matrix whose elements are:\n\nC_ij =\nbegincases\nleft A_i - B_j right  textif all  A_ik - B_jk  d_k \ninfty  textotherwise\nendcases\n\nwhere d is a vector of cutoff values for each dimension of the data.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.jaccard-Tuple{Array{<:Real}, Array{<:Real}, Vector{<:Real}}","page":"Home","title":"SMLMMetrics.jaccard","text":"jaccard(a::Array{<:Real}, b::Array{<:Real}, cutoff::Vector{<:Real})\n\na and b are d x n, and d x m arrays, where d is the number of dimensions  \n\ncutoff contains the maximum matching distance for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.jaccard-Tuple{SMLMData.SMLD2D, SMLMData.SMLD2D, Vector{<:Real}}","page":"Home","title":"SMLMMetrics.jaccard","text":"jaccard(a::SMLMData.SMLD2D, b::SMLMData.SMLD2D, cutoff::Vector{<:Real})\n\nComputes the Jaccard index for two sets of 2D localizations represented by SMLD2D structures a and b.\n\nArguments\n\na::SMLMData.SMLD2D: First set of localizations\nb::SMLMData.SMLD2D: Second set of localizations\ncutoff::Vector{<:Real}: A vector of cutoff distances for each dimension\n\nReturns\n\nFloat64: Jaccard index between the two sets of localizations\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.jaccard-Tuple{SMLMData.SMLD3D, SMLMData.SMLD3D, Vector{<:Real}}","page":"Home","title":"SMLMMetrics.jaccard","text":"jaccard(a::SMLMData.SMLD3D, b::SMLMData.SMLD3D, cutoff::Vector{<:Real})\n\nComputes the Jaccard index for two sets of 3D localizations represented by SMLD3D structures a and b.\n\nArguments\n\na::SMLMData.SMLD3D: First set of localizations\nb::SMLMData.SMLD3D: Second set of localizations\ncutoff::Vector{<:Real}: A vector of cutoff distances for each dimension\n\nReturns\n\nFloat64: Jaccard index between the two sets of localizations\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.match-Tuple{Array{<:Real}, Array{<:Real}, Vector{<:Real}}","page":"Home","title":"SMLMMetrics.match","text":"match(a::Array{<:Real}, b::Array{<:Real}, cutoff::Vector{<:Real})\n\nFind the best matching pairs of points between a and b based on Euclidean distance,  with a specified maximum acceptable distance for each dimension defined in cutoff.\n\nThe function uses the Hungarian algorithm to find the optimal assignment that minimizes the total distance between pairs. \n\nParameters:\n\na and b are d x n and d x m arrays, respectively, where d is the number of dimensions.\ncutoff is a d-dimensional vector, specifying the maximum acceptable distance in each dimension.\n\nThe function returns a n-dimensional vector, where the ith element is the index of the point in b that is matched with the ith point in a. If the ith point in a has no match in b (i.e., the distance to all points in b is larger than the cutoff), then the ith element of the returned vector is 0.\n\nThe function uses a cost matrix approach, where the cost is the Euclidean distance between points. If the  distance between a pair of points exceeds the cutoff, the cost is set to a large value to effectively eliminate  that pairing from consideration. The Hungarian algorithm is then used to find the assignment that minimizes the  total cost. The cost matrix and the assignment are adjusted such that pairs with a cost equal to the large value  are unassigned (i.e., set to 0 in the assignment vector).\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.rmse-Tuple{Any, Any}","page":"Home","title":"SMLMMetrics.rmse","text":"function rmse(a, b)\n\nCalculate the root mean square error between a and b.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.rmse-Tuple{Array{<:Real}, Array{<:Real}, Vector{<:Real}, Vector{Int64}}","page":"Home","title":"SMLMMetrics.rmse","text":"rmse(a::Array{<:Real}, b::Array{<:Real}, α::Vector{<:Real}, assignment::Vector{Int})\n\nCalculate the root mean square error using a dimensional weighting α, only for the matched pairs.\n\na and b are d x n, and d x m arrays, where d is the number of dimensions\n\nRMSE = sqrtfrac1dfrac1Nsum_k=1^dalpha_k^2sum_n=1^N (a_ki-b_kassignmenti)^2\n\nassignment is the output from the match function, and assignment[i] gives the index in b that matches with the ith element in a. If assignment[i] == 0, then the ith element in a has no match in b.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.rmse-Tuple{Array{<:Real}, Array{<:Real}, Vector{<:Real}}","page":"Home","title":"SMLMMetrics.rmse","text":"function rmse(a::Array{<:Real}, b::Array{<:Real}, α::Vector{<:Real})\n\nCalculate the root mean square error using a dimensional weighting α.\n\na and b are d x n, and d x m arrays, where d is the number of dimensions\n\nRMSE = (frac1dfrac1NSigma_k=1^dalpha_k^2Sigma_n=1^N      (a_ki-b_ki)^2)^12\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.rmse-Tuple{SMLMData.SMLD2D, SMLMData.SMLD2D}","page":"Home","title":"SMLMMetrics.rmse","text":"rmse(a::SMLMData.SMLD2D, b::SMLMData.SMLD2D; α::Vector{<:Real} = ones(2))\n\nComputes the root mean squared error (RMSE) for two sets of 2D localizations represented by SMLD2D structures a and b.\n\nArguments\n\na::SMLMData.SMLD2D: First set of localizations\nb::SMLMData.SMLD2D: Second set of localizations\nα::Vector{<:Real}: Optional weight vector for each dimension (default is ones(2))\n\nReturns\n\nFloat64: RMSE between the two sets of localizations\n\n\n\n\n\n","category":"method"},{"location":"#SMLMMetrics.rmse-Tuple{SMLMData.SMLD3D, SMLMData.SMLD3D}","page":"Home","title":"SMLMMetrics.rmse","text":"rmse(a::SMLMData.SMLD3D, b::SMLMData.SMLD3D; α::Vector{<:Real} = [1e-2, 1e-2, 5e-2])\n\nComputes the root mean squared error (RMSE) for two sets of 3D localizations represented by SMLD3D structures a and b.\n\nArguments\n\na::SMLMData.SMLD3D: First set of localizations\nb::SMLMData.SMLD3D: Second set of localizations\nα::Vector{<:Real}: Optional weight vector for each dimension (default is [1e-2, 1e-2, 5e-2])\n\nReturns\n\nFloat64: RMSE between the two sets of localizations\n\n\n\n\n\n","category":"method"}]
}
